# FLINT+ — Описание функций по файлам

## 1. PROJ5.CPP — Главный модуль (~1539 строк)

### `int main()`
**Точка входа программы.** Инициализирует все глобальные переменные (параметры по умолчанию), загружает конфигурацию из cfg-файла, инициализирует BGI-графику (EGA/VGA 640×480), проверяет наличие оборудования (`pi_ini()`), инициализирует мышь, выделяет память под массив точек `iTabl[]` (максимально возможный объём far-памяти), загружает счётчик вспышек и запускает главный цикл обработки событий. В главном цикле — вызов `mainscr()` для перерисовки, `scan_ms()` для ожидания действия пользователя и переключение по кнопкам (F1–F10).

---

### Функции GUI (кнопки и элементы управления)

#### `void button(int btc[], int nmb, char buttxt[])`
Рисует **обычную (ненажатую) кнопку** с 3D-эффектом. Координаты и размеры берутся из массива `btc[]` по индексу `nmb`. Рисуется чёрная тень, серый фон и текст кнопки.

#### `void buttonp(int btc[], int nmb, char buttxt[])`
Рисует **нажатую кнопку** (инвертированный 3D-эффект — тень сверху-слева). Текст смещается на 1 пиксель вниз и вправо, создавая визуальный эффект нажатия.

#### `void ctlbt(int btxl, int btyl, int colctl, char ctltxt[])`
Рисует **чекбокс** — квадрат 10×10 пикселей с текстовой меткой справа. Используется для переключателей (1/9 образцов, Mirror, Invert и т.д.).

#### `int pressbt(int bt[], int nm)`
Проверяет, находится ли текущая позиция мыши (`coord[]`) внутри области кнопки с номером `nm`. Возвращает 1 если попадание, 0 если нет.

#### `void sw_ctl(int flag, int param, int xpos, int ypos, int col)`
Рисует состояние **переключателя** (radio button/checkbox). Если `flag == param` — рисует активный цвет (COL_ON), иначе — цвет фона. Заливает внутренность квадрата 10×10.

#### `int draw_bt(int btc[], char *bnam[], int nmb)`
Рисует **набор кнопок** для диалогового окна. Перебирает массив `btc[]`, для типа 1 рисует кнопку (`button()`), для типа 3 — чекбокс (`ctlbt()`). Возвращает 1.

---

### Диалоговые окна / сообщения

#### `int msgbox(char msgtxt[], int more)`
Выводит **модальное окно сообщения** с текстом. Параметр `more`: 0 — кнопки Ok/No, ненулевой — добавляется кнопка «Next pix:» (Nx) для пропуска проблемной точки. Сохраняет и восстанавливает фоновое изображение. Возвращает: 1=Ok, 0=No, 2=Next.

#### `void infobox(char msgtxt[])`
Выводит окно **«О программе»** с информацией об ILTiP Ltd, адресом, телефоном, версией и **растровой иконкой** (нарисованной попиксельно из массива `fico[]`).

#### `int msg(int msgx, int msgy, int onoff, char msgtxt[])`
**Управление информационным сообщением** на экране. `onoff=1` — показать (сохраняя фон), `onoff=0` — убрать (восстановить фон). Используется для «Please wait», «For STOP: press ESC» и т.д.

#### `void WndBkgr(int xl, int yt, int xr, int yb, int col, char txt[])`
Рисует **фон диалогового окна**: чёрная тень, цветной фон, рамка, заголовок и две горизонтальные разделительные линии (сверху и снизу для кнопок).

---

### Диалог конфигурации

#### `int dlgcfg(void)`
Открывает **окно «Configuration»** (F1). Позволяет настраивать:
- Координаты указателя (Xptr/Yptr/Zptr) с перемещением стола в реальном времени
- Шаг (Step), частоту шагов (Step freq), период лазера (Las.puls period)
- Режим 1/9 образцов с выбором позиций затворов (матрица 3×3)
- Constant/Variable режим частоты
- Защиту (Protect open/close) и ручной лазерный импульс
- Лазерную юстировку (Las.adjust) — непрерывные импульсы
- Загрузку/сохранение cfg, сброс счётчика вспышек и даты обслуживания

Возвращает 1 при Ok, 0 при Cancel.

---

### Диалог конверсии данных

#### `int dlged(void)`
Открывает **окно «Data Convert»** (F2). Основная рабочая область для подготовки объектов:
- Загрузка из bft/cft/asc/bmp
- Просмотр в 4 проекциях (XY, YX, XZ, YZ) с автомасштабированием
- Редактирование: показатель преломления (n), размеры образца (X/Y/Z), тип стекла
- Смещение объекта кнопками up/dn/←/→ или вводом dT/dL/dR/dB
- Зеркалирование (Mirror), инвертирование (Invert)
- Центрирование: «0→Center» и «C→Center»
- Сортировка (Sort), масштабирование (Dimensions)
- Сохранение в bft/cft/asc

При сохранении применяется коррекция по показателю преломления стекла (деление Z-координат на n).

---

### Диалог открытия/сохранения файлов

#### `int dlgopen(char destnm[], char dlgnm[], int flag)`
**Универсальное окно выбора файлов.** Отображает текущий путь, список каталогов (с навигацией up/down), список файлов, фильтр по расширению (bft/cft/asc/bmp), возможность ввода имени файла с клавиатуры, смену диска. Параметр `flag` определяет набор доступных расширений (0=bft/cft, 1=bft/cft/asc, 2=bft/cft/asc/bmp). Для bmp — дополнительные поля dx/dy/dz. Возвращает 1 при Ok (имя файла в `destnm`), 0 при Cancel.

#### `int disksel(int nmb)`
Выводит **выпадающий список доступных дисков** (A:–J:). Возвращает номер выбранного диска или -1 при отмене.

#### `void chdiska(void)`
**Переключает текущий диск** обратно на рабочий, если текущий — дисковод (A: или B:). Защита от зависания при отсутствии дискеты.

---

### Ввод чисел

#### `int inp_dig(int xl, int yt, double min, double max, int ax)`
**Клавиатурный ввод числового значения** в указанную область экрана. Поддерживает цифры и точку, Backspace, ESC (отмена), Enter (подтверждение с проверкой диапазона). Параметр `ax`: 0 — записать в nglas, 1 — умножить на 10 (мм→0.1мм), 2 — умножить на 100 (мм→0.01мм). Возвращает введённое значение или -1 при отмене.

#### `int InrDcr(int param, int pmin, int pmax, int pstep, int updn)`
**Инкремент/декремент параметра** с ограничением диапазона. `updn=1` — увеличить, `updn=0` — уменьшить. Используется для всех кнопок +/- в интерфейсе.

---

### Загрузка стекла

#### `void glload(int direct)`
**Перемещает координатный стол** вверх (direct=0) или вниз (direct=1) для загрузки/выгрузки образца. Включает шаговые двигатели, вызывает `move_sen()`, затем выключает.

#### `int dlgload(void)`
Окно **«Glass Load»** (F4). Кнопки Up/Down/Cancel. При Up — привязка к концевым датчикам (do_ptr=1), при Down — сброс (do_ptr=0).

---

### Выбор стекла

#### `int gselect(void)`
Окно **«Glass select»**. Загружает список марок стекла из [FLINT.GLS](FLINT.GLS), отображает их с показателями преломления, позволяет выбрать. При Ok — устанавливает `nglas` и `glstype`.

---

### Запуск обработки

#### `int dlgstart(void)`
Окно **«Start»** (F5). Выбор режима старта (Beginning/Point number/Continuation/Saved in CMOS), настройка реакции на шум (Stop/Coord.reboot/Ignore), переключение End sensors и Drawing check. При Ok — проверка данных (`minmax()`), запуск `process()`, запись счётчика вспышек.

---

### Статистика

#### `void ClearRpt(void)`
**Обнуляет массив** `nmrpt[20]` — счётчики повторных попыток для каждого из 10 затворов (по 2 значения: первая и последующие попытки).

#### `int dlgstat(void)`
Окно **«Statistics»** (F6). Отображает: общее число вспышек, дату обслуживания, текущие ошибки затворов (errnmb) — визуально на матрице 3×3 + десятый, число повторов по каждому затвору, общее количество повторов.

---

### Главный экран

#### `void mainscr(int all)`
Рисует **главный экран** программы. Параметр `all`: 1 — полная перерисовка (фон, кнопки, данные), 0 — только контрольная картинка. Фон — градиентный паттерн из синих полос. Выводит: имя файла, Nmax, Nlast, параметры стекла, демо-индикатор, расчётное время, контрольную картинку.

#### `void glaspos(int xl, int yt, int cw)`
Рисует **матрицу 3×3 позиций затворов** для работы с 9 образцами. Каждая активная позиция (бит в `cw`) закрашивается цветом COL_ON.

#### `void drawfl(void)`
Рисует **логотип «FLINT»** из растрового массива `flint[]` — чёрная тень + светло-голубой текст, попиксельная отрисовка.

---

### Отрисовка объекта

#### `void draw(int flag, int all)`
**Рисует контрольную картинку** загруженного объекта. `flag` определяет проекцию (0=XY, 1=YX, 2=XZ, 3=YZ). `all`: 1 — все точки (обработанные — COL_ON, оставшиеся — COLBKL), 0 — только текущую точку. Автомасштабирование по размеру образца.

#### `void DrawPix(int hp, int hs, int vp, int vs, int color)`
Рисует **одну точку** контрольной картинки с проверкой попадания в границы.

---

### Сортировка

#### `int dlgsort(void)`
Окно **«Sorting»**. Выбор режима сортировки: Off / 0.5mm layers / K*dz. Настройка коэффициентов K1 (при dz>0) и K2 (при dz<0). Кнопка «Sort/time» — запуск сортировки с отображением расчётного времени обработки.

#### `int sort(void)`
**Двухэтапная сортировка «0.5mm layers»:**
1. Сортировка всех точек по Z-координате (selection sort)
2. В пределах каждого слоя (dZ=50, т.е. 0.5 мм) — сортировка по min(max(|dX|, |dY|)) для минимизации пути перемещения

Прерывается по ESC. Возвращает 1 при успехе, 0 при отмене.

#### `int sort2(void)`
**Сортировка «K*dz»** — жадный алгоритм ближайшего соседа с весовыми коэффициентами:
1. Находит точку с минимальной Z
2. Для каждой точки находит ближайшую следующую по оценке `cros()` = max(|dX|, |dY|) + dZ*K/10 (K=K1 при dz>0, K=K2 при dz<0)

#### `long cros(unsigned long k1, unsigned long k2)`
**Вычисляет «стоимость» перехода** между двумя точками: max(|dX|, |dY|) + dZ*K/10. Учитывает направление по Z через разные коэффициенты K1/K2.

#### `void swap(unsigned long k1, unsigned long k2)`
**Обменивает местами** две точки (X, Y, Z) в массиве `iTabl[]`.

---

### Проверки и вычисления

#### `int minmax(void)`
Находит **минимальные и максимальные координаты** объекта по X, Y, Z (с учётом показателя преломления для Z). Возвращает: 1 — данные в пределах и образца, и привода; 0 — за пределами привода; -1 — за пределами образца.

---

### Обработка событий

#### `unsigned int scan_ms(int btc[], char *bnam[], int nbt)`
**Главный цикл обработки кнопок** — ожидает клик мыши или нажатие клавиши:
- При нажатии мыши — проверяет попадание в кнопки, визуально нажимает кнопку, обрабатывает autorepeat
- При отпускании — подтверждает нажатие (для типа release)
- При нажатии клавиши — возвращает 255 (код клавиши в `pkey`)

Возвращает номер нажатой кнопки или 255 (клавиша).

---

### Прогресс и время

#### `void progbar(long nmb_max, long nmb, int set, int xl, int yt)`
Рисует **ProgressBar**: `set=1` — инициализация (рисует пустую полосу), `set=0` — обновление текущего прогресса. Синие полоски и процент справа.

#### `void htime(char tmpstr[])`
**Рассчитывает время обработки** объекта на основе текущих параметров (l_period, step_freq) и суммы перемещений между точками. Записывает строку вида «Time: hh:mm:ss» в `tmpstr`.

---

### Масштабирование

#### `int dlgdim()`
Окно **«Dimensions Modification»**. Позволяет масштабировать объект:
- Единый коэффициент K (50%–200%) или раздельные Kx/Ky/Kz
- Относительно начала координат или центра образца
- При Ok — пересчитывает все координаты в `iTabl[]`

---

## 2. PIC.CPP — Модуль управления оборудованием (~421 строка)

### `int pi_ini(void)`
**Инициализация всех плат расширения.** Настраивает:
- Регистр управления RG (все оси выключены, генератор включён)
- Регистр лазера LRG (накачка и затвор выключены)
- PPI: режим 0, PA-выход (K1=150, ~100kHz), PB-вход, PC-выход (моторы вкл, лазер активен, защита закрыта)
- PPI2: режим 0, все 10 затворов закрыты
- PT0, PT1, PT2: программируемые таймеры в соответствующих режимах

Проверяет ответ PPI — если нет ответа, возвращает 0 (демо-режим), иначе 1.

### `int lpuls(void)`
**Выполняет лазерный импульс** с контролем затворов. Алгоритм:
1. Определяет маску активных затворов (1 или 9 образцов)
2. Если есть ошибка — открывает только нужные затворы
3. Делает до 10 попыток: отправляет импульс, читает датчики, проверяет какие затворы не сработали
4. При ошибке — открывает невыполненные затворы и повторяет
5. Ведёт статистику повторов (`nmrpt[]`)
6. В демо-режиме просто увеличивает счётчик

Возвращает 1 — успех, 0 — ошибка (не все затворы сработали за 10 попыток).

### `void sh_open(unsigned int pos)`
**Открывает электромагнитные затворы** по битовой маске `pos` (биты 0–9 соответствуют EM1–EM10). Записывает в PPI2, отправляет команду подключения и ждёт SH_TIME (50 мс) на стабилизацию.

### `void sh_close(void)`
**Закрывает все электромагнитные затворы** — записывает 0xFF в PB PPI2 и устанавливает PC4, PC5, PC6 в 1.

### `int process(void)`
**Основной цикл обработки объекта.** Проходит по всем точкам `iTabl[]` от `start_nmb` до `nmax`:
1. Инициализирует привязку к датчикам (если нужна)
2. Открывает затвор безопасности и затворы образцов
3. Для каждой точки: вычисляет целевые координаты (с учётом показателя преломления), вызывает `move()`, затем `lpuls()`
4. При ошибке `lpuls()` — диалог «Check laser. Retry: Ok» с возможностью повтора/пропуска/выхода
5. Инкрементирует CMOS-счётчик, рисует текущую точку, обновляет Nlast и ProgressBar
6. Проверяет ESC для прерывания

Возвращает 1 — объект обработан полностью, 0 — прервано.

### `int move_sen(int dir)`
**Привязка координатного стола к концевым датчикам:**
- `dir=0` (Up): движение X+/Y-/Z- до срабатывания endSensors, затем X-/Y+ до точки отсчёта. Устанавливает `xcur=23300, ycur=200, zcur=200`
- `dir=1` (Down): обратное движение для выгрузки образца

Контролирует два этапа: быстрое движение к датчикам (F=1000Hz), затем медленное позиционирование (F=500Hz).

### `int move(int x, int y, int z)`
**Перемещает координатный стол** в точку (x, y, z). Алгоритм:
1. Вычисляет смещения dx, dy, dz от текущей позиции
2. Рассчитывает K2 (делитель частоты) для каждой оси:
   - В режиме variable: K2 = (l_period-3)*100/|d| (чтобы перемещение заняло ~l_period мс)
   - В режиме constant: K2 = 100000/step_freq
3. Программирует таймеры PT0/PT1 (дистанции и частоты)
4. Устанавливает направления и запускает генератор
5. Ожидает сигнала завершения (IRQ2 для XY, IRQ3 для Z)
6. При срабатывании endSensors — откат на 200 шагов и возврат ошибки
7. Компенсирует оставшееся время l_period задержкой

В демо-режиме — просто задержка l_period мс. Возвращает 1 — успех, 0 — ошибка (endSensors).

---

## 3. MSKEYC.CPP — Модуль ввода (~165 строк)

### `void out_time(int newt)`
**Выводит текущее время** (ЧЧ:ММ:СС) в левом верхнем углу экрана. Обновляет каждую секунду. Сохраняет и восстанавливает цвета рисования. Вызывается из всех циклов ожидания — обеспечивает «живые часы».

### `void set_gr_cursor(int hot_spot_row, int hot_spot_column, unsigned int far *scr_cur_masks)`
**Устанавливает графический курсор мыши** через INT 33h (функция AX=9). Принимает маски AND/XOR для формирования стрелки.

### `void ms_init(void)`
**Инициализирует драйвер мыши** через INT 33h (функция AX=0). При отсутствии мыши — завершение программы с сообщением «no mouse!».

### `void ms_state(struct MOUSE_STATE *current_state)`
**Читает текущее состояние мыши** — нажатые кнопки, горизонтальную и вертикальную позиции (функция AX=3).

### `void ms_move(int h_pos, int v_pos)`
**Перемещает курсор мыши** в заданную позицию (функция AX=4). Используется для перемещения курсора стрелками клавиатуры.

### `int ms_release(struct MOUSE_STATE *current_state)`
**Читает количество отпусканий кнопки** мыши и позицию (функция AX=6). Возвращает число button-release events.

### `void beep(int tone, int duration)`
**Звуковой сигнал** заданной частоты (Гц) и длительности (мс). Используется для сигнализации ошибок и окончания обработки.

### `int ms_key_cmd(void)`
**Главный обработчик ввода** — ожидает действие от мыши или клавиатуры:
- **Левая кнопка мыши (нажатие):** запоминает координаты, возвращает 0
- **Левая кнопка мыши (отпускание):** возвращает 1
- **Автоповтор:** при удержании — первая задержка 500мс, далее каждые 10мс
- **Клавиши-стрелки:** перемещают курсор мыши на 8 пикселей
- **F1–F10:** возвращают скан-коды (59–68)
- **Enter:** возвращает ENTER (13)
- **ESC:** возвращает ESC (27)
- Другие клавиши — звуковой сигнал

В цикле ожидания постоянно обновляет часы (`out_time()`).

---

## 4. RDWRF.CPP — Модуль файлового ввода-вывода (~401 строка)

### Общие файловые операции

#### `int rdfile(char filename[], char masname[], unsigned int nmb)`
**Чтение бинарного файла** целиком в буфер. Открывает файл, читает `nmb` байт в `masname`, закрывает. Для чтения cfg и произвольных данных.

#### `int wrfile(char filename[], char masname[], unsigned int nmb)`
**Запись бинарного файла** — записывает `nmb` байт из `masname` в файл. Для сохранения cfg.

---

### Конфигурация

#### `void RdCfg(int gl_nmber)`
**Читает файл конфигурации** (flint1.cfg при gl_nmber=0 или flint9.cfg при gl_nmber=1). Парсит строки: Xptr, Yptr, Zptr, Step, l_period, step_freq, f_const. Для 9-образцового режима дополнительно — glpos9 (позиции затворов).

---

### Счётчик вспышек

#### `void FlashRd(void)`
**Читает файл flash.dat** (8 байт) из рабочего каталога. Восстанавливает `ulFlash` (общее число лазерных вспышек, 4 байта, big-endian) и `ulService` (дата обслуживания, 4 байта).

#### `void FlashWr(void)`
**Записывает flash.dat** — сохраняет текущие значения `ulFlash` и `ulService` в 8-байтный бинарный файл.

---

### Работа с каталогами

#### `void CurDir(void)`
**Получает текущий путь** — формирует строку вида «C:\path\...» из текущего диска и каталога.

#### `int rddir(char f_namext[])`
**Читает содержимое текущего каталога** — подкаталоги (до 48 штук) в `dname[]` и файлы с указанным расширением (до 98 штук) в `mname[]`. Сортирует оба списка. Возвращает 1 если файлы найдены, 0 если нет.

#### `void sort_fnm(void)`
**Сортирует массив имён файлов** `mname[]` по алфавиту (selection sort, посимвольное сравнение).

#### `void sort_dnm(void)`
**Сортирует массив имён каталогов** `dname[]` по алфавиту. Каталог «..» всегда остаётся первым.

---

### Чтение данных

#### `long rdcft_t(char filename[])`
**Читает файл в формате CFT** (Character Flint Table) в `iTabl[]`. Парсит заголовок «flinttab», параметры nglas/xsize/ysize/zsize, затем строки «номер: X Y Z». Возвращает число точек, 0 при ошибке формата, -1 при переполнении буфера.

#### `long rdbft_t(char filename[])`
**Читает файл в формате BFT** (Binary Flint Table) в `iTabl[]`. Проверяет сигнатуру «bf» (0x6662), загружает параметры (nglas, xsize, ysize, zsize, nmb), читает массив координат. Возвращает число точек, 0 при ошибке, -1 при переполнении.

#### `int rdasc_t(char filename[])`
**Читает файл в формате ASC** (3D Studio ASCII) в `iTabl[]`. Ищет строки с «X:», «Y:», «Z:», парсит координаты. Y-координата инвертируется (делится на -1). Возвращает 0 при успехе, 1 при переполнении, -1 при ошибке открытия.

#### `long rdbmp(char filename[])`
**Читает 2-цветный BMP-файл** и конвертирует чёрные пиксели в 3D-координаты. Проверяет сигнатуру «BM», размеры, что это действительно B&W BMP. Координаты: X = column * dx, Y = row * dy, Z = шахматный паттерн * dz. Устанавливает размер образца по размеру изображения. Возвращает число точек.

#### `int rdgls(void)`
**Читает базу типов стёкол** из [FLINT.GLS](FLINT.GLS) в массив `gtype[50][16]`. Каждая строка — марка стекла и показатель преломления. Возвращает количество записей.

---

### Запись данных

#### `int wrasc(char filename[])`
**Записывает данные в формат ASC** (3D Studio). Формирует заголовок (Ambient light, Named object, Tri-mesh), затем для каждой точки — строку «Vertex N: X: ... Y: ... Z: ...». Y-координата инвертируется. Точки выводятся в мм (деление на 10).

#### `int wrt_cft(char filename[])`
**Записывает данные в формат CFT.** Формирует заголовок «flinttab» + параметры (nglas, xsize, ysize, zsize), затем строки «номер:\tX\tY\tZ\n». Размеры в мм (деление на 10).

#### `int wrt_bft(char filename[])`
**Записывает данные в формат BFT.** Пишет заголовок из 7 слов (сигнатура «bf», nglas*1000, xsize, ysize, zsize, nmax_high, nmax_low) и массив координат `iTabl[]`.

---

## 5. PROJ5.H — Заголовочный файл (~447 строк)

Заголовочный файл не содержит функций, но определяет критически важные данные:

### Константы и макросы
- **Адреса портов**: ADRPT0 (0x300), ADRPPI (0x308), ADRRG (0x30C), ADRCMOS (0x318)
- **Управление мышью**: CURSOR_ON(), CURSOR_OFF() через INT 33h
- **Клавиши**: ESC (27), ENTER (13)
- **Цвета**: COLDLG (3), COLBK (56), COLBKL (59), COL_ON (60)
- **Биты управления**: STEP_ON/OFF, PULS_ON/OFF, PR_OPEN/CLOSE
- **Координаты картинки**: X0 (160), Y0 (450)

### Массивы кнопок (btc_xxx[] / bnam_xxx[])
Для каждого диалогового окна определены массивы:
- **btc_scr[]** — 9 кнопок главного экрана (F9 XYZ, F1–F7, F10 Exit)
- **btc_cfg[]** — 27+9 кнопок конфигурации
- **btc_opn[]** — 12+ кнопок диалога открытия файлов
- **btc_ed[]** — 31 кнопка диалога конверсии
- **btc_gload[]** — 3 кнопки загрузки стекла
- **btc_gsel[]** — 5 кнопок выбора стекла
- **btc_strt[]** — 15 кнопок запуска
- **btc_stat[]** — 1 кнопка статистики
- **btc_msg[]** — 2-3 кнопки сообщения
- **btc_sort[]** — 9 кнопок сортировки
- **btc_dim[]** — 14 кнопок масштабирования

Каждый элемент: [тип, режим_нажатия, x, y, ширина, высота]

### Растровые данные
- **scr_cur_masks[]** — маски AND/XOR для графического курсора мыши (стрелка)
- **pattern[][8]** — 20 паттернов заливки (от сплошного до пустого) для градиентного фона
- **flint[]** — растровое изображение логотипа «FLINT» (34 строки × 15 байт)
- **fico[]** — иконка ILTiP (28 строк × 4 слова, 2-цветная)

### Глобальные переменные
Все глобальные переменные программы (~60+ переменных), включая:
- Состояние приводов (xcur, ycur, zcur, xptr, yptr, zptr)
- Параметры объекта (nmax, nglas, xsize, ysize, zsize)
- Флаги режимов (f_demo, f_data, f_sort, f_const, f_mirror и т.д.)
- Буферы (iTabl, bitmapmsg, mname, dname, gtype)
- Счётчики (ulFlash, ulService, nmrpt, errnmb)

### Прототипы функций
Объявления всех функций из всех модулей (PROJ5.CPP, PIC.CPP, MSKEYC.CPP, RDWRF.CPP).
