# FLINT+ v2.77 — Описание функций по файлам

*Версия: 2.77, сентябрь 2004*

## 1. PROJ5.CPP — Главный модуль (~1631 строк)

### `int main()`
**Точка входа программы.** Инициализирует все глобальные переменные (параметры по умолчанию), загружает конфигурацию из cfg-файла, инициализирует BGI-графику (EGA/VGA 640×480), проверяет наличие оборудования (`pi_ini()`), инициализирует мышь, выделяет память под массив точек `iTabl[]` (упрощённый расчёт: `farcoreleft()-30000`), загружает счётчик вспышек и запускает главный цикл обработки событий. В главном цикле — вызов `mainscr()` для перерисовки, `scan_ms()` для ожидания действия пользователя и переключение по кнопкам (F1–F10).

---

### Функции GUI (кнопки и элементы управления)

#### `void button(int btc[], int nmb, char buttxt[])`
Рисует **обычную (ненажатую) кнопку** с 3D-эффектом. Координаты и размеры берутся из массива `btc[]` по индексу `nmb`. Рисуется чёрная тень, серый фон и текст кнопки.

#### `void buttonp(int btc[], int nmb, char buttxt[])`
Рисует **нажатую кнопку** (инвертированный 3D-эффект — тень сверху-слева). Текст смещается на 1 пиксель вниз и вправо, создавая визуальный эффект нажатия.

#### `void ctlbt(int btxl, int btyl, int colctl, char ctltxt[])`
Рисует **чекбокс** — квадрат 10×10 пикселей с текстовой меткой справа. Используется для переключателей (1/9 образцов, Mirror, Invert и т.д.).

#### `int pressbt(int bt[], int nm)`
Проверяет, находится ли текущая позиция мыши (`coord[]`) внутри области кнопки с номером `nm`. Возвращает 1 если попадание, 0 если нет.

#### `void sw_ctl(int flag, int param, int xpos, int ypos, int col)`
Рисует состояние **переключателя** (radio button/checkbox). Если `flag == param` — рисует активный цвет (COL_ON), иначе — цвет фона. Заливает внутренность квадрата 10×10.

#### `int draw_bt(int btc[], char *bnam[], int nmb)`
Рисует **набор кнопок** для диалогового окна. Перебирает массив `btc[]`, для типа 1 рисует кнопку (`button()`), для типа 3 — чекбокс (`ctlbt()`). Возвращает 1.

---

### Диалоговые окна / сообщения

#### `int msgbox(char msgtxt[], int more, int f_beep=0)`
Выводит **модальное окно сообщения** с текстом. Параметр `more`: 0 — кнопки Ok/No, ненулевой — добавляется кнопка «Next pix:» (Nx) для пропуска проблемной точки. Параметр `f_beep` передаётся в `scan_ms()` для периодического звукового сигнала при критических сообщениях. Сохраняет и восстанавливает фоновое изображение. Возвращает: 1=Ok, 0=No, 2=Next.

#### `int msg(int msgx, int msgy, int onoff, char msgtxt[])`
**Управление информационным сообщением** на экране. `onoff=1` — показать (сохраняя фон), `onoff=0` — убрать (восстановить фон). Используется для «Please wait», «For STOP: press ESC» и т.д.

#### `void WndBkgr(int xl, int yt, int xr, int yb, int col, char txt[])`
Рисует **фон диалогового окна**: чёрная тень, цветной фон, рамка, заголовок и две горизонтальные разделительные линии (сверху и снизу для кнопок).

---

### Диалог конфигурации

#### `int dlgcfg(void)`
Открывает **окно «Configuration»** (F1). 28 кнопок (`BNM_CFG=28`). Позволяет настраивать:
- Координаты указателя (Xptr/Yptr/Zptr) с перемещением стола в реальном времени
- Шаг (Step), частоту шагов (Step freq), период лазера (Las.puls period, макс. 655)
- Задержку затвора gate_delay (1–50, ×10 мкс) с кнопками +/−
- Переключатели Pump (вкл/выкл накачки) и Gate (вкл/выкл затвора)
- Режим 1/9 образцов с выбором позиций затворов (матрица 3×3), кнопка «X» для очистки позиций
- Constant/Variable режим частоты
- Защиту (Protect open/close)
- Отображение параметров dT и sh_delay
- Загрузку/сохранение cfg (сохранение — инлайн через `wrfile()`, без отдельной WrCfg), сброс счётчика вспышек и даты обслуживания
- Перепрограммирование PT2 через флаг `f_pt2` и `program_pt2()`

Возвращает 1 при Ok, 0 при Cancel.

---

### Диалог конверсии данных

#### `int dlged(void)`
Открывает **окно «Data Convert»** (F2). Основная рабочая область для подготовки объектов:
- Загрузка из bft/cft/asc/bmp
- Просмотр в 4 проекциях (XY, YX, XZ, YZ) с автомасштабированием. **Добавлена быстрая клавиша F9** (pkey==67) для переключения проекции XYZ
- Редактирование: показатель преломления (n), размеры образца (X/Y/Z), тип стекла
- Смещение объекта кнопками up/dn/←/→ или вводом dT/dL/dR/dB
- Зеркалирование (Mirror), инвертирование (Invert)
- Центрирование: «0→Center» и «C→Center»
- Сортировка (Sort), масштабирование (Dimensions)
- Сохранение в bft/cft/asc

При сохранении применяется коррекция по показателю преломления стекла (деление Z-координат на n).

---

### Диалог открытия/сохранения файлов

#### `int dlgopen(char destnm[], char dlgnm[], int flag)`
**Универсальное окно выбора файлов.** Отображает текущий путь, список каталогов (с навигацией up/down), список файлов, фильтр по расширению (bft/cft/asc/bmp), возможность ввода имени файла с клавиатуры, смену диска. Параметр `flag` определяет набор доступных расширений (0=bft/cft, 1=bft/cft/asc, 2=bft/cft/asc/bmp). Для bmp — дополнительные поля dx/dy/dz. Возвращает 1 при Ok (имя файла в `destnm`), 0 при Cancel.

#### `int disksel(int nmb)`
Выводит **выпадающий список доступных дисков** (A:–J:). Возвращает номер выбранного диска или -1 при отмене.

#### `void chdiska(void)`
**Переключает текущий диск** обратно на рабочий, если текущий — дисковод (A: или B:). Защита от зависания при отсутствии дискеты.

---

### Ввод чисел

#### `long inp_dig(int xl, int yt, double min, double max, int ax)`
**Клавиатурный ввод числового значения** в указанную область экрана. Поддерживает цифры и точку, Backspace, ESC (отмена), Enter (подтверждение с проверкой диапазона). Параметр `ax`: 0 — записать в nglas, 1 — умножить на 10 (мм→0.1мм), 2 — умножить на 100 (мм→0.01мм). Возвращает введённое значение или -1 при отмене.

#### `int InrDcr(int param, int pmin, int pmax, int pstep, int updn)`
**Инкремент/декремент параметра** с ограничением диапазона. `updn=1` — увеличить, `updn=0` — уменьшить. Используется для всех кнопок +/- в интерфейсе.

---

### Загрузка стекла

#### `void glload(int direct)`
**Перемещает координатный стол** вверх (direct=0) или вниз (direct=1) для загрузки/выгрузки образца. Включает шаговые двигатели, вызывает `move_sen()`, затем выключает.

#### `int dlgload(void)`
Окно **«Glass Load»** (F4). Кнопки Up/Down/Cancel. При Up — привязка к концевым датчикам (do_ptr=1), при Down — сброс (do_ptr=0). **Добавлены клавиши PgUp (73) и PgDn (81)** для прокрутки списка.

---

### Выбор стекла

#### `int gselect(void)`
Окно **«Glass select»**. Загружает список марок стекла из [FLINT.GLS](FLINT.GLS), отображает их с показателями преломления, позволяет выбрать. При Ok — устанавливает `nglas` и `glstype`.

---

### Запуск обработки

#### `int dlgstart(void)`
Окно **«Start»** (F5). 14 кнопок (`BNM_STRT=14`). Выбор режима старта (Beginning/Point number/Continuation/Saved in CMOS), настройка реакции на шум (Stop/Coord.reboot/Ignore), переключение End sensors и Drawing check. Прямой ввод номера точки через `inp_dig()` (case 13). При Ok — проверка данных (`minmax()`), запуск `process()`, запись счётчика вспышек.

---

### Статистика

#### `void ClearRpt(void)`
**Обнуляет массив** `nmrpt[10]` — счётчики повторных попыток для каждого из 10 затворов.

---

### Главный экран

#### `void mainscr(int all)`
Рисует **главный экран** программы. 7 кнопок (`BNM_SCR=7`). Параметр `all`: 1 — полная перерисовка (фон, кнопки, данные), 0 — только контрольная картинка. Фон — градиентный паттерн из синих полос. Выводит: имя файла, Nmax, Nlast, параметры стекла, демо-индикатор, расчётное время, контрольную картинку, **номер версии «2.77»** на экране, **индикатор Dr.check** (ctlbt в левой панели), **сетку реитераций 3×3** внизу экрана (через `show_reit()`).

#### `void glaspos(int xl, int yt, int cw)`
Рисует **матрицу 3×3 позиций затворов** для работы с 9 образцами. Каждая активная позиция (бит в `cw`) закрашивается цветом COL_ON.

#### `void drawfl(void)`
Рисует **логотип «FLINT»** из растрового массива `flint[]` — чёрная тень + светло-голубой текст, попиксельная отрисовка.

#### `void show_reit(int mode)`
**Рисует сетку 3×3** с реальными счётчиками реитераций для каждой позиции стекла. Параметр `mode`: 0 — только метки, 1 — подсветка позиций с ошибками цветом `COL_ON`. Используется переменная `errnmb` (битовая маска ошибок). Отображается на главном экране и обновляется в реальном времени во время обработки.

---

### Отрисовка объекта

#### `void draw(int flag, int all)`
**Рисует контрольную картинку** загруженного объекта. `flag` определяет проекцию (0=XY, 1=YX, 2=XZ, 3=YZ). `all`: 1 — все точки (обработанные — COL_ON, оставшиеся — COLBKL), 0 — только текущую точку. Автомасштабирование по размеру образца.

#### `void DrawPix(int hp, int hs, int vp, int vs, int color)`
Рисует **одну точку** контрольной картинки с проверкой попадания в границы.

---

### Сортировка

#### `int dlgsort(void)`
Окно **«Sorting»**. Выбор режима сортировки: Off / 0.5mm layers / K*dz. Настройка коэффициентов K1 (при dz>0) и K2 (при dz<0). Кнопка «Sort/time» — запуск сортировки с отображением расчётного времени обработки.

#### `int sort(void)`
**Двухэтапная сортировка «0.5mm layers»:**
1. Сортировка всех точек по Z-координате (selection sort)
2. В пределах каждого слоя (dZ=50, т.е. 0.5 мм) — сортировка по min(max(|dX|, |dY|)) для минимизации пути перемещения

Прерывается по ESC. Возвращает 1 при успехе, 0 при отмене.

#### `int sort2(void)`
**Сортировка «K*dz»** — жадный алгоритм ближайшего соседа с весовыми коэффициентами:
1. Находит точку с минимальной Z
2. Для каждой точки находит ближайшую следующую по оценке `cros()` = max(|dX|, |dY|) + dZ*K/10 (K=K1 при dz>0, K=K2 при dz<0)

#### `long cros(unsigned long k1, unsigned long k2)`
**Вычисляет «стоимость» перехода** между двумя точками: max(|dX|, |dY|) + dZ*K/10. Учитывает направление по Z через разные коэффициенты K1/K2.

#### `void swap(unsigned long k1, unsigned long k2)`
**Обменивает местами** две точки (X, Y, Z) в массиве `iTabl[]`.

---

### Проверки и вычисления

#### `int minmax(void)`
Находит **минимальные и максимальные координаты** объекта по X, Y, Z (с учётом показателя преломления для Z). Максимальный предел по Z: 12000. Возвращает: 1 — данные в пределах и образца, и привода; 0 — за пределами привода; -1 — за пределами образца.

---

### Обработка событий

#### `unsigned int scan_ms(int btc[], char *bnam[], int nbt, int f_beep=0)`
**Главный цикл обработки кнопок** — ожидает клик мыши или нажатие клавиши:
- При нажатии мыши — проверяет попадание в кнопки, визуально нажимает кнопку, обрабатывает autorepeat
- При отпускании — подтверждает нажатие (для типа release)
- При нажатии клавиши — возвращает 255 (код клавиши в `pkey`)
- Параметр `f_beep` передаётся в `ms_key_cmd()` для периодического звукового сигнала

Возвращает номер нажатой кнопки или 255 (клавиша).

---

### Прогресс и время

#### `void progbar(long nmb_max, long nmb, int set, int xl, int yt)`
Рисует **ProgressBar**: `set=1` — инициализация (рисует пустую полосу), `set=0` — обновление текущего прогресса. Синие полоски и процент справа.

#### `void htime(char tmpstr[])`
**Рассчитывает время обработки** объекта на основе текущих параметров (l_period, step_freq) и суммы перемещений между точками. Записывает строку вида «Time: hh:mm:ss» в `tmpstr`.

---

### Масштабирование

#### `int dlgdim()`
Окно **«Dimensions Modification»**. Позволяет масштабировать объект:
- Единый коэффициент K (50%–200%) или раздельные Kx/Ky/Kz
- Относительно начала координат или центра образца
- При Ok — пересчитывает все координаты в `iTabl[]`

---

## 2. PIC.CPP — Модуль управления оборудованием (~501 строк)

### `int pi_ini(void)`
**Инициализация всех плат расширения.** Настраивает:
- Регистр управления RG (все оси выключены, генератор включён)
- Регистр лазера LRG (накачка и затвор выключены)
- PPI: режим 0, PA-выход (K1=150, ~100kHz), PB-вход, PC-выход (моторы вкл, лазер активен, защита закрыта)
- PPI2: режим 0, все 10 затворов закрыты
- PT0, PT1, PT2: программируемые таймеры в соответствующих режимах

Проверяет ответ PPI — если нет ответа, возвращает 0 (демо-режим), иначе 1.

### `int seg_time(int adx, int ady, int adz)`
**Оценивает число тактов лазера** (`l_period`-интервалов), необходимых для перемещения на (adx, ady, adz) шагов. Формула: `max(|adx|,|ady|,|adz|)*1000/step_freq / l_period + 1`, с поправкой на `dT`. Добавлена в v2.73. Используется в `move()` (через `calc_k2()`) и в `htime()` (через `extern` в PROJ5.CPP). Определена в PIC.CPP, прототип объявлен через `extern` в PROJ5.CPP.

### `int lpuls(int flag)`
**Выполняет лазерный импульс** с контролем затворов. Параметр `flag` определяет начальное состояние затвора. Алгоритм:
1. Определяет маску активных затворов (1 или 9 образцов)
2. Если есть ошибка — открывает только нужные затворы
3. Делает до **11 попыток** с **10-элементным массивом** `nmrpt[k]`
4. **Синхронизация через PT2** (`read_pt2()`) вместо прямого управления портами
5. **Программируемая задержка затвора** для каждого импульса через `program_pt2()`
6. Затвор переоткрывается только при смене рабочей позиции (`wrkpos != prevwrkpos`)
7. Проверка ESC внутри цикла повторов
8. Ведёт статистику повторов (`nmrpt[]`)
9. В демо-режиме просто увеличивает счётчик

Возвращает 1 — успех, 0 — ошибка (не все затворы сработали за 11 попыток).

### `void sh_open(unsigned int pos)`
**Открывает электромагнитные затворы** по битовой маске `pos` (биты 0–9 соответствуют EM1–EM10). Записывает в PPI2, отправляет команду подключения и ждёт `sh_delay` мс на стабилизацию.

### `void sh_close(void)`
**Закрывает все электромагнитные затворы** — записывает 0xFF в PB PPI2 и устанавливает PC4, PC5, PC6 в 1.

### `int process(void)`
**Основной цикл обработки объекта.** Проходит по всем точкам `iTabl[]` от `start_nmb` до `nmax`:
1. Инициализирует привязку к датчикам (если нужна)
2. Открывает затвор безопасности и затворы образцов
3. Для каждой точки: вычисляет целевые координаты (с учётом показателя преломления), вызывает `move()`, затем `lpuls()`
4. При ошибке `lpuls()` — диалог «Check laser. Retry: Ok» с возможностью повтора/пропуска/выхода. Звуковой сигнал (`f_beep`) при ошибках KPU и TABLE END
5. **Отображение реитераций** в реальном времени через `show_reit(1)`
6. **Индикатор Dr.check** — красная полоска при ошибке, вызов `glaspos()` для подсветки проблемных позиций
7. Инкрементирует CMOS-счётчик, рисует текущую точку, обновляет Nlast и ProgressBar
8. Проверяет ESC для прерывания

Возвращает 1 — объект обработан полностью, 0 — прервано.

### `int move_sen(int dir)`
**Привязка координатного стола к концевым датчикам:**
- `dir=0` (Up): движение X+/Y-/Z- до срабатывания endSensors, затем X-/Y+ до точки отсчёта. Устанавливает `xcur=23300, ycur=200, zcur=200`
- `dir=1` (Down): обратное движение для выгрузки образца

Контролирует два этапа: быстрое движение к датчикам (F=1000Hz), затем медленное позиционирование (K2=200, dX/dY/dZ=200 шагов).

### `long calc_k2(int delta, int t)`
**Вычисляет делитель частоты K2** для одной оси. Формула: `(t * l_period - dT) * 100 / |delta|`, результат ограничен диапазоном `[100000/step_freq, 65500]`. При `f_const=1` возвращает `100000/step_freq`. Добавлена в v2.77. Локальная функция PIC.CPP (без прототипа в PROJ5.H).

### `int move(int x, int y, int z)`
**Перемещает координатный стол** в точку (x, y, z). Алгоритм:
1. Вычисляет смещения dx, dy, dz от текущей позиции
2. Вызывает `seg_time(dx,dy,dz)` для определения числа тактов `t`
3. Рассчитывает K2 (делитель частоты) для каждой оси через `calc_k2(delta, t)`:
   - В режиме variable: K2 = (t\*l_period - dT)\*100/|delta|, ограничен `[100000/step_freq, 65500]`
   - В режиме constant: K2 = 100000/step_freq
4. Программирует таймеры PT0/PT1 (дистанции и частоты)
5. Устанавливает направления и запускает генератор
6. Ожидает сигнала завершения (IRQ2 для XY, IRQ3 для Z)
7. При срабатывании endSensors — откат на 200 шагов и возврат ошибки
8. Компенсирует оставшееся время l_period задержкой

В демо-режиме — просто задержка l_period мс. Возвращает 1 — успех, 0 — ошибка (endSensors).

### `void program_pt2(int period, unsigned char gate)`
**Программирует таймер PT2** — устанавливает период и ширину gate (задержку затвора). Используется при инициализации (`pi_ini()`), в `lpuls()` для программируемой задержки затвора, и в `dlgcfg()` при изменении параметров.

### `unsigned int read_pt2(void)`
**Читает текущее значение счётчика PT2.ch0** (Counter Latch + чтение low/high байт). Возвращает 16-битное значение счётчика. Используется в `lpuls()` для синхронизации лазерных импульсов.

---

## 3. MSKEYC.CPP — Модуль ввода (~170 строк)

### `void out_time(int newt)`
Пустой стаб (тело функции удалено, все вызовы в коде сохранены как no-op). Ранее выводила текущее время в левом верхнем углу экрана, но вызывала пропуск ~1 лазерного импульса в секунду из-за задержки обращения к BIOS.

### `void set_gr_cursor(int hot_spot_row, int hot_spot_column, unsigned int far *scr_cur_masks)`
**Устанавливает графический курсор мыши** через INT 33h (функция AX=9). Принимает маски AND/XOR для формирования стрелки.

### `void ms_init(void)`
**Инициализирует драйвер мыши** через INT 33h (функция AX=0). При отсутствии мыши — завершение программы с сообщением «no mouse!».

### `void ms_state(struct MOUSE_STATE *current_state)`
**Читает текущее состояние мыши** — нажатые кнопки, горизонтальную и вертикальную позиции (функция AX=3).

### `void ms_move(int h_pos, int v_pos)`
**Перемещает курсор мыши** в заданную позицию (функция AX=4). Используется для перемещения курсора стрелками клавиатуры.

### `int ms_release(struct MOUSE_STATE *current_state)`
**Читает количество отпусканий кнопки** мыши и позицию (функция AX=6). Возвращает число button-release events.

### `void beep(int tone, int duration)`
**Звуковой сигнал** заданной частоты (Гц) и длительности (мс). Используется для сигнализации ошибок и окончания обработки.

### `int ms_key_cmd(int f_beep)`
**Главный обработчик ввода** — ожидает действие от мыши или клавиатуры:
- **Левая кнопка мыши (нажатие):** запоминает координаты, возвращает 0
- **Левая кнопка мыши (отпускание):** возвращает 1
- **Автоповтор:** при удержании — первая задержка 500мс, далее каждые 10мс
- **Клавиши-стрелки:** перемещают курсор мыши на 8 пикселей
- **F1–F10, PgUp (73), PgDn (81), Home, End:** возвращают скан-коды
- **Enter:** возвращает ENTER (13)
- **ESC:** возвращает ESC (27)
- **Параметр `f_beep`:** при ненулевом значении — периодический звуковой сигнал для критических сообщений
- Другие клавиши — звуковой сигнал

---

## 4. RDWRF.CPP — Модуль файлового ввода-вывода (~417 строк)

### Общие файловые операции

#### `int rdfile(char filename[], char masname[], unsigned int nmb)`
**Чтение бинарного файла** целиком в буфер. Открывает файл, читает `nmb` байт в `masname`, закрывает. Для чтения cfg и произвольных данных.

#### `int wrfile(char filename[], char masname[], unsigned int nmb)`
**Запись бинарного файла** — записывает `nmb` байт из `masname` в файл. Для сохранения cfg.

---

### Конфигурация

#### `void RdCfg(int gl_nmber)`
**Читает файл конфигурации** (flint1.cfg при gl_nmber=0 или flint9.cfg при gl_nmber=1). Буфер 50 байт. Парсит 10–11 полей: Xptr, Yptr, Zptr, Step, l_period, **gate_delay**, step_freq, f_const, **dT**, **sh_delay**. Для 9-образцового режима дополнительно — glpos9 (позиции затворов).

> **Примечание:** Отдельная функция `WrCfg()` в исходниках v2.77 отсутствует. Сохранение конфигурации реализовано инлайн в `dlgcfg()` ([PROJ5.CPP](../Flint%202.77%20src/PROJ5.CPP), case 3): формирование строки из 10–11 полей (Xptr, Yptr, Zptr, Step, l_period, gate_delay, step_freq, f_const, dT, sh_delay [, glpos9]) и вызов `wrfile()`.

---

### Счётчик вспышек

#### `void FlashRd(void)`
**Читает файл flash.dat** (8 байт) из рабочего каталога. Восстанавливает `ulFlash` (общее число лазерных вспышек, 4 байта, big-endian) и `ulService` (дата обслуживания, 4 байта).

#### `void FlashWr(void)`
**Записывает flash.dat** — сохраняет текущие значения `ulFlash` и `ulService` в 8-байтный бинарный файл.

---

### Работа с каталогами

#### `void CurDir(void)`
**Получает текущий путь** — формирует строку вида «C:\path\...» из текущего диска и каталога.

#### `int rddir(char f_namext[])`
**Читает содержимое текущего каталога** — подкаталоги (до 48 штук) в `dname[]` и файлы с указанным расширением (до 98 штук) в `mname[]`. Сортирует оба списка. Возвращает 1 если файлы найдены, 0 если нет.

#### `void sort_fnm(void)`
**Сортирует массив имён файлов** `mname[]` по алфавиту (selection sort, посимвольное сравнение).

#### `void sort_dnm(void)`
**Сортирует массив имён каталогов** `dname[]` по алфавиту. Каталог «..» всегда остаётся первым.

---

### Чтение данных

#### `long rdcft_t(char filename[])`
**Читает файл в формате CFT** (Character Flint Table) в `iTabl[]`. Парсит заголовок «flinttab», параметры nglas/xsize/ysize/zsize, затем строки «номер: X Y Z». Возвращает число точек, 0 при ошибке формата, -1 при переполнении буфера.

#### `long rdbft_t(char filename[])`
**Читает файл в формате BFT** (Binary Flint Table) в `iTabl[]`. Проверяет сигнатуру «bf» (0x6662), загружает параметры (nglas, xsize, ysize, zsize, nmb), читает массив координат. Возвращает число точек, 0 при ошибке, -1 при переполнении.

#### `int rdasc_t(char filename[])`
**Читает файл в формате ASC** (3D Studio ASCII) в `iTabl[]`. Ищет строки с «X:», «Y:», «Z:», парсит координаты. Y-координата инвертируется (делится на -1). Возвращает 0 при успехе, 1 при переполнении, -1 при ошибке открытия.

#### `long rdbmp(char filename[])`
**Читает 2-цветный BMP-файл** и конвертирует чёрные пиксели в 3D-координаты. Проверяет сигнатуру «BM», размеры, что это действительно B&W BMP. Координаты: X = column * dx, Y = row * dy, Z = шахматный паттерн * dz. Устанавливает размер образца по размеру изображения. Возвращает число точек.

#### `int rdgls(void)`
**Читает базу типов стёкол** из [FLINT.GLS](FLINT.GLS) в массив `gtype[50][16]`. Каждая строка — марка стекла и показатель преломления. Возвращает количество записей.

---

### Запись данных

#### `int wrasc(char filename[])`
**Записывает данные в формат ASC** (3D Studio). Формирует заголовок (Ambient light, Named object, Tri-mesh), затем для каждой точки — строку «Vertex N: X: ... Y: ... Z: ...». Y-координата инвертируется. Точки выводятся в мм (деление на 10).

#### `int wrt_cft(char filename[])`
**Записывает данные в формат CFT.** Формирует заголовок «flinttab» + параметры (nglas, xsize, ysize, zsize), затем строки «номер:\tX\tY\tZ\n». Размеры в мм (деление на 10).

#### `int wrt_bft(char filename[])`
**Записывает данные в формат BFT.** Пишет заголовок из 7 слов (сигнатура «bf», nglas*1000, xsize, ysize, zsize, nmax_high, nmax_low) и массив координат `iTabl[]`.

---

## 5. PROJ5.H — Заголовочный файл (~467 строк)

Заголовочный файл не содержит функций, но определяет критически важные данные:

### Константы и макросы
- **Адреса портов**: ADRPT0 (0x300), **ADRPT1 (0x304)**, ADRPPI (0x308), ADRRG (0x30C), **ADRPPI2 (0x310)**, **ADRPT2 (0x314)**, ADRCMOS (0x318), **LRG (0x31C)**
- **Управление лазером (новые)**: PUMP_ON, PUMP_OFF (вкл/выкл накачки, D0), SHUT_ON, SHUT_OFF (вкл/выкл затвора, D1)
- **Управление мышью**: CURSOR_ON(), CURSOR_OFF() через INT 33h
- **Клавиши**: ESC (27), ENTER (13)
- **Цвета**: COLDLG (3), COLBK (56), COLBKL (59), COL_ON (60)
- **Координаты картинки**: X0 (160), Y0 (450)

### Массивы кнопок (btc_xxx[] / bnam_xxx[])
Для каждого диалогового окна определены массивы:
- **btc_scr[]** — 7 кнопок главного экрана (`BNM_SCR=7`)
- **btc_cfg[]** — 28+9 кнопок конфигурации (`BNM_CFG=28`)
- **btc_opn[]** — 12+ кнопок диалога открытия файлов
- **btc_ed[]** — 31 кнопка диалога конверсии
- **btc_gload[]** — 3 кнопки загрузки стекла
- **btc_gsel[]** — 5 кнопок выбора стекла
- **btc_strt[]** — 14 кнопок запуска (`BNM_STRT=14`)
- **btc_msg[]** — 2-3 кнопки сообщения
- **btc_sort[]** — 9 кнопок сортировки
- **btc_dim[]** — 14 кнопок масштабирования

Каждый элемент: [тип, режим_нажатия, x, y, ширина, высота]

### Растровые данные
- **scr_cur_masks[]** — маски AND/XOR для графического курсора мыши (стрелка)
- **pattern[][8]** — 20 паттернов заливки (от сплошного до пустого) для градиентного фона
- **flint[]** — растровое изображение логотипа «FLINT» (34 строки × 15 байт)
- **fico[]** — иконка ILTiP (28 строк × 4 слова, 2-цветная)

### Глобальные переменные
Все глобальные переменные программы (~60+ переменных), включая:
- Состояние приводов (xcur, ycur, zcur, xptr, yptr, zptr)
- Параметры объекта (nmax, nglas, xsize, ysize, zsize)
- Флаги режимов (f_demo, f_data, f_sort, f_const, f_mirror и т.д.)
- Буферы (iTabl, bitmapmsg, mname, dname, gtype)
- Счётчики (ulFlash, ulService, nmrpt, errnmb)
- `gate_delay` (int) — задержка затвора (1–50, в единицах 10 мкс)
- `dT` (int) — коррекция CPU для таймингов перемещения (мс)
- `sh_delay` (int) — задержка электромеханического затвора (мс)
- `f_gate` (int) — флаг состояния gate

### Прототипы функций
Объявления всех функций из всех модулей (PROJ5.CPP, PIC.CPP, MSKEYC.CPP, RDWRF.CPP).
